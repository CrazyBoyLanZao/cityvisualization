<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Three</title>
  <style type="text/css">
    html, body {
      margin: 0;
      height: 100%;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body onload="draw();">
</body>
<script src="js/three.js"></script>
<script src="js/OrbitControls.js"></script>
<script src="js/stats.min.js"></script>
<script src="js/OBJLoader.js"></script>
<script src="js/shaders/ConvolutionShader.js"></script>
<script src="js/shaders/CopyShader.js"></script>

<script src="js/postprocessing/EffectComposer.js"></script>
<script src="js/postprocessing/RenderPass.js"></script>
<script src="js/postprocessing/MaskPass.js"></script>
<script src="js/postprocessing/BloomPass.js"></script>
<script src="js/postprocessing/ShaderPass.js"></script>
<script src="js/dat.gui.min.js"></script>
<script>

  // import {Geometry} from "./js/three.module";

  var renderer;
  var scene;
  var camera;
  var background;
  var controls;
  var raycaster = new THREE.Raycaster();
  var mouse = new THREE.Vector2();
  //初始化dat.GUI简化试验流程
  var gui = new dat.GUI();
  //初始化性能插件
  var stats;



  var dynamicball;//气象球
  var dynamicball_data = new Array(11);
  var bar,bar_data = new Array( 11 ),bar_bg;//直方图
  var hourbaro;//晴雨表
  var barpx = [-38.127, 57.588, 166.838, 143.005, -306.147, -104.218, 1.008, -213.550, 274.628, 133.300, -188.876]//从1到11城市x坐标
  var barpz = [298.619, -371.138, 254.960, -41.957, 275.872, 70.806 , 465.187, 500.891, 82.418, 140.921, 220.631]//y坐标



  function initRender() {
    renderer = new THREE.WebGLRenderer({antialias: true,alpha:true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.setClearColor(0x000000);
    document.body.appendChild(renderer.domElement);
  }

  function initCamera() {
    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1e10);
    camera.position.set(0, 0, -2e3);
    camera.lookAt(new THREE.Vector3(0, 0, 0));
  }

  function initScene() {
    scene = new THREE.Scene();
    background = new THREE.CubeTextureLoader()
      .setPath( 'img/' )
      .load( [ 'dark-s_px.jpg', 'dark-s_nx.jpg', 'dark-s_py.jpg', 'dark-s_ny.jpg', 'dark-s_pz.jpg', 'dark-s_nz.jpg' ] );//环境
    background.format = THREE.RGBFormat;
    scene.background = background;
  }

  function initLight() {
    let ambient = new THREE.AmbientLight(0xffffff);
    let light = new THREE.HemisphereLight(0xffffff,0xffffff);
    light.position.set(5e9,5e9,5e9);
    scene.add(ambient);
    scene.add(light);
  }//光照

  function AQIColor(AQI){
    let colors = [
      '#0000ff',
      '#0099ff',
      '#00ffee',
      '#00ff99',
      '#00ff33',
      '#33ff00',
      '#99ff00',
      '#ffee00',
      '#ff8800',
      '#ff5500'
    ]
    return colors[ Math.ceil( AQI/226 ) % 10 ];
  }

  function init(){
    bar = new THREE.Group();
    for(let i = 1; i <= 11; i++){
      bar_data[i] = new THREE.Mesh(
              new THREE.CylinderGeometry(30,30,500,50),
              new THREE.MeshStandardMaterial({
                color: 0xffffff
              })
      );
      bar_data[i].position.x = barpx[ i - 1 ];
      bar_data[i].position.y = 250;
      bar_data[i].position.z = barpz[ i - 1 ];
      bar.add(bar_data[i]);
    }

    bar_bg = new THREE.Mesh(
            new THREE.CubeGeometry(1000,1400,50),
            new THREE.MeshStandardMaterial({
              color:　0xffffff,
              map: THREE.ImageUtils.loadTexture('model/bar/map.png',{},function (){
                renderer.render( scene , camera );
              }),
              side: THREE.DoubleSide,
            })
    );
    bar_bg.rotation.x = Math.PI / 2;
    bar.add(bar_bg);
    scene.add(bar);

    dynamicball = new THREE.Group();
    for(let i = 0; i < 11; i++ ){
      dynamicball_data[i] = new THREE.Mesh(
              new THREE.SphereGeometry(100,10,10),
              new THREE.MeshStandardMaterial({
                color: 0xffffff
              })
      )
      dynamicball.add(dynamicball_data[i]);//将所有城市的球体添加到组
    }
    scene.add(dynamicball);//大组添加到环境

    /***************晴雨表*************************/

    hourbaro = new THREE.Group();
    hourbarodata = new Array(11*24);	//立方体组
    hourbaro_back = new THREE.Group();	//昨天组
    hourbaro_next = new THREE.Group();	//明天组
    hourbaro_bg = new THREE.Mesh(
            new THREE.CubeGeometry(2000,20,900),
            new THREE.MeshStandardMaterial({
              color:　0xffffff,
              map: THREE.ImageUtils.loadTexture('model/barometer/background.png',{},function (){
                renderer.render( scene , camera );
              }),
              side: THREE.DoubleSide,
              opacity: 0.99,
              transparent: true
            })
    );
    hourbarodata_bg = new THREE.Mesh(
            new THREE.CubeGeometry(1300,20,680),
            new THREE.MeshStandardMaterial({
              color:　0xffffff,
              map: THREE.ImageUtils.loadTexture('model/barometer/excel.png',{},function (){
                renderer.render( scene , camera );
              }),
              side: THREE.DoubleSide,
            })
    );
    hourbaro_bg.rotation.x = -Math.PI / 2;
    hourbarodata_bg.rotation.x = -Math.PI / 2;
    hourbaro_back_mesh = new THREE.Mesh(
            new THREE.CubeGeometry(50,40,20),
            new THREE.MeshStandardMaterial({
              color: 0xeeeeff,
              map: THREE.ImageUtils.loadTexture('model/barometer/back.png',{},function (){
                renderer.render( scene , camera );
              }),
            })
    );
    hourbaro_back.add(hourbaro_back_mesh);
    hourbaro_next_mesh = new THREE.Mesh(
            new THREE.CubeGeometry(50,40,20),
            new THREE.MeshStandardMaterial({
              color: 0xeeeeff,
              map: THREE.ImageUtils.loadTexture('model/barometer/next.png',{},function (){
                renderer.render( scene , camera );
              }),
              //side: THREE.DoubleSide
            })
    );
    hourbaro_next.add(hourbaro_next_mesh);

    hourbaro_bg.position.z -= 350;
    hourbarodata_bg.position.y -= 80;
    hourbarodata_bg.position.z -= 200;
    hourbaro_back.position.x -= 700;
    hourbaro_next.position.x += 700;
    /****550*1200****/
    for(let i = 0; i < 11; i++){
      for(let j = 0; j < 24; j++){
        hourbarodata[ i * 24 + j ] = new THREE.Mesh(
                new THREE.CubeGeometry(30,30,50),
                new THREE.MeshStandardMaterial({
                  color: 0xffffff
                })//依次创建立方体
        );
        hourbarodata[ i * 24 + j ].position.x = j * 50 - 600 + 50;
        hourbarodata[ i * 24 + j ].position.y = i * 50 - 275 - 50 - 50;
        hourbarodata[ i * 24 + j ].position.z = 0;
        hourbaro.add(hourbarodata[ i * 24 + j ]);//添加所有立方体
      }
    }
    hourbaro.add(hourbaro_next,hourbaro_back,hourbarodata_bg,hourbaro_bg);//添加按钮，表格
    hourbaro.position.y = 1000;
    hourbaro.position.z -= 1500;
    scene.add(hourbaro);
  }

  function onMouseClick( event ) {

    //通过鼠标点击的位置计算出raycaster所需要的点的位置，以屏幕中心为原点，值的范围为-1到1.

    mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
    mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

    // 通过鼠标点的位置和当前相机的矩阵计算出raycaster
    raycaster.setFromCamera( mouse, camera );

    // 获取raycaster直线和所有模型相交的数组集合
    var intersects = raycaster.intersectObjects( scene.children );

    // console.log(intersects);

    //将所有的相交的模型的颜色设置为红色，如果只需要将第一个触发事件，那就数组的第一个模型改变颜色即可
    for ( var i = 0; i < intersects.length; i++ ) {

      intersects[ i ].object.material.color.set( 0xff0000 );

    }

  }

  window.addEventListener( 'click', onMouseClick, false );







  function initControls() {

    controls = new THREE.OrbitControls(camera, renderer.domElement);

    // 如果使用animate方法时，将此函数删除
    //controls.addEventListener( 'change', render );
    // 使动画循环使用时阻尼或自转 意思是否有惯性
    controls.enableDamping = true;
    //动态阻尼系数 就是鼠标拖拽旋转灵敏度
    //controls.dampingFactor = 0.25;
    //是否可以缩放
    controls.enableZoom = true;
    //是否自动旋转
    controls.autoRotate = false;
    //设置相机距离原点的最远距离
    controls.minDistance = 0;
    //设置相机距离原点的最远距离
    controls.maxDistance = 1e10;
    //是否开启右键拖拽
    controls.enablePan = true;
  }

  function render() {



    renderer.render(scene, camera);

  }

  //窗口变动触发的函数
  function onWindowResize() {

    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    render();
    renderer.setSize(window.innerWidth, window.innerHeight);

  }

  function animate() {
    render();
    //按数组更换坐标
    requestAnimationFrame(animate);
  }

  function draw() {
    initRender();
    initScene();
    initCamera();
    initLight();
    init();
    initControls();
    animate();
    window.onresize = onWindowResize;
  }
</script>
</html>
